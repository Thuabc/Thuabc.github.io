<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://thuabc.github.io</id>
    <title>Tanghua&apos;s Blogs</title>
    <updated>2019-12-19T01:22:20.335Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://thuabc.github.io"/>
    <link rel="self" href="https://thuabc.github.io/atom.xml"/>
    <subtitle>学而不思则罔</subtitle>
    <logo>https://thuabc.github.io/images/avatar.png</logo>
    <icon>https://thuabc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Tanghua&apos;s Blogs</rights>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://thuabc.github.io/post/mysql</id>
        <link href="https://thuabc.github.io/post/mysql">
        </link>
        <updated>2019-12-18T15:03:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- GFM-TOC -->
<ul>
<li><a href="#%E4%B8%80%E7%B4%A2%E5%BC%95">一、索引</a>
<ul>
<li><a href="#b-tree-%E5%8E%9F%E7%90%86">B+ Tree 原理</a></li>
<li><a href="#mysql-%E7%B4%A2%E5%BC%95">MySQL 索引</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">索引优化</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">索引的优点</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6">索引的使用条件</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">二、查询性能优化</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-explain-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90">使用 Explain 进行分析</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">优化数据访问</a></li>
<li><a href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">重构查询方式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">三、存储引擎</a>
<ul>
<li><a href="#innodb">InnoDB</a></li>
<li><a href="#myisam">MyISAM</a></li>
<li><a href="#%E6%AF%94%E8%BE%83">比较</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">四、数据类型</a>
<ul>
<li><a href="#%E6%95%B4%E5%9E%8B">整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F">时间和日期</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%88%87%E5%88%86">五、切分</a>
<ul>
<li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86">水平切分</a></li>
<li><a href="#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86">垂直切分</a></li>
<li><a href="#sharding-%E7%AD%96%E7%95%A5">Sharding 策略</a></li>
<li><a href="#sharding-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Sharding 存在的问题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%A4%8D%E5%88%B6">六、复制</a>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主从复制</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">读写分离</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1 id="一-索引">一、索引</h1>
<h2 id="b-tree-原理">B+ Tree 原理</h2>
<h3 id="1-数据结构">1. 数据结构</h3>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br>
<h3 id="2-操作">2. 操作</h3>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p>
<h3 id="3-与红黑树的比较">3. 与红黑树的比较</h3>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p>
<p>（一）更少的查找次数</p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p>（二）利用磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id="mysql-索引">MySQL 索引</h2>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h3 id="1-btree-索引">1. B+Tree 索引</h3>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" width="350px"> </div><br>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" width="350px"> </div><br>
<h3 id="2-哈希索引">2. 哈希索引</h3>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h3 id="3-全文索引">3. 全文索引</h3>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h3 id="4-空间数据索引">4. 空间数据索引</h3>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引优化">索引优化</h2>
<h3 id="1-独立的列">1. 独立的列</h3>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<pre><code class="language-sql">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
</code></pre>
<h3 id="2-多列索引">2. 多列索引</h3>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<pre><code class="language-sql">SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
</code></pre>
<h3 id="3-索引列的顺序">3. 索引列的顺序</h3>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<pre><code class="language-sql">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
</code></pre>
<pre><code class="language-html">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre>
<h3 id="4-前缀索引">4. 前缀索引</h3>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h3 id="5-覆盖索引">5. 覆盖索引</h3>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h2 id="索引的优点">索引的优点</h2>
<ul>
<li>
<p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li>
<p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li>
<p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h2 id="索引的使用条件">索引的使用条件</h2>
<ul>
<li>
<p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li>
<p>对于中到大型的表，索引就非常有效；</p>
</li>
<li>
<p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
<h1 id="二-查询性能优化">二、查询性能优化</h1>
<h2 id="使用-explain-进行分析">使用 Explain 进行分析</h2>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h2 id="优化数据访问">优化数据访问</h2>
<h3 id="1-减少请求的数据量">1. 减少请求的数据量</h3>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h3 id="2-减少服务器端扫描的行数">2. 减少服务器端扫描的行数</h3>
<p>最有效的方式是使用索引来覆盖查询。</p>
<h2 id="重构查询方式">重构查询方式</h2>
<h3 id="1-切分大查询">1. 切分大查询</h3>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<pre><code class="language-sql">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);
</code></pre>
<pre><code class="language-sql">rows_affected = 0
do {
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
} while rows_affected &gt; 0
</code></pre>
<h3 id="2-分解大连接查询">2. 分解大连接查询</h3>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<pre><code class="language-sql">SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
</code></pre>
<pre><code class="language-sql">SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
</code></pre>
<h1 id="三-存储引擎">三、存储引擎</h1>
<h2 id="innodb">InnoDB</h2>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h2 id="myisam">MyISAM</h2>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h2 id="比较">比较</h2>
<ul>
<li>
<p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
</li>
<li>
<p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
</li>
<li>
<p>外键：InnoDB 支持外键。</p>
</li>
<li>
<p>备份：InnoDB 支持在线热备份。</p>
</li>
<li>
<p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
</li>
<li>
<p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
</li>
</ul>
<h1 id="四-数据类型">四、数据类型</h1>
<h2 id="整型">整型</h2>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h2 id="浮点数">浮点数</h2>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h2 id="字符串">字符串</h2>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h2 id="时间和日期">时间和日期</h2>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h3 id="1-datetime">1. DATETIME</h3>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22<span>:</span>37<span>:</span>08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h3 id="2-timestamp">2. TIMESTAMP</h3>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h1 id="五-切分">五、切分</h1>
<h2 id="水平切分">水平切分</h2>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" width=""> </div><br>
<h2 id="垂直切分">垂直切分</h2>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" width=""> </div><br>
<h2 id="sharding-策略">Sharding 策略</h2>
<ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h2 id="sharding-存在的问题">Sharding 存在的问题</h2>
<h3 id="1-事务问题">1. 事务问题</h3>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<h3 id="2-连接">2. 连接</h3>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<h3 id="3-id-唯一性">3. ID 唯一性</h3>
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
<h1 id="六-复制">六、复制</h1>
<h2 id="主从复制">主从复制</h2>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong>  ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong>  ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong>  ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png" width=""> </div><br>
<h2 id="读写分离">读写分离</h2>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" width=""> </div><br>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li>
<li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li>
<li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases">How to create unique row ID in sharded databases?</a></li>
<li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry.">SQL Azure Federation – Introduction</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li>
<li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">How Sharding Works</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html">大众点评订单系统分库分表实践</a></li>
<li><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B + 树</a></li>
</ul>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL]]></title>
        <id>https://thuabc.github.io/post/sql</id>
        <link href="https://thuabc.github.io/post/sql">
        </link>
        <updated>2019-12-18T15:02:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- GFM-TOC -->
<ul>
<li><a href="#%E4%B8%80%E5%9F%BA%E7%A1%80">一、基础</a></li>
<li><a href="#%E4%BA%8C%E5%88%9B%E5%BB%BA%E8%A1%A8">二、创建表</a></li>
<li><a href="#%E4%B8%89%E4%BF%AE%E6%94%B9%E8%A1%A8">三、修改表</a></li>
<li><a href="#%E5%9B%9B%E6%8F%92%E5%85%A5">四、插入</a></li>
<li><a href="#%E4%BA%94%E6%9B%B4%E6%96%B0">五、更新</a></li>
<li><a href="#%E5%85%AD%E5%88%A0%E9%99%A4">六、删除</a></li>
<li><a href="#%E4%B8%83%E6%9F%A5%E8%AF%A2">七、查询</a></li>
<li><a href="#%E5%85%AB%E6%8E%92%E5%BA%8F">八、排序</a></li>
<li><a href="#%E4%B9%9D%E8%BF%87%E6%BB%A4">九、过滤</a></li>
<li><a href="#%E5%8D%81%E9%80%9A%E9%85%8D%E7%AC%A6">十、通配符</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">十一、计算字段</a></li>
<li><a href="#%E5%8D%81%E4%BA%8C%E5%87%BD%E6%95%B0">十二、函数</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E5%88%86%E7%BB%84">十三、分组</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B%E5%AD%90%E6%9F%A5%E8%AF%A2">十四、子查询</a></li>
<li><a href="#%E5%8D%81%E4%BA%94%E8%BF%9E%E6%8E%A5">十五、连接</a></li>
<li><a href="#%E5%8D%81%E5%85%AD%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">十六、组合查询</a></li>
<li><a href="#%E5%8D%81%E4%B8%83%E8%A7%86%E5%9B%BE">十七、视图</a></li>
<li><a href="#%E5%8D%81%E5%85%AB%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B">十八、存储过程</a></li>
<li><a href="#%E5%8D%81%E4%B9%9D%E6%B8%B8%E6%A0%87">十九、游标</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E8%A7%A6%E5%8F%91%E5%99%A8">二十、触发器</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">二十一、事务管理</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%AD%97%E7%AC%A6%E9%9B%86">二十二、字符集</a></li>
<li><a href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">二十三、权限管理</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1 id="一-基础">一、基础</h1>
<p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<pre><code class="language-sql"># 注释
SELECT *
FROM mytable; -- 注释
/* 注释1
   注释2 */
</code></pre>
<p>数据库创建与使用：</p>
<pre><code class="language-sql">CREATE DATABASE test;
USE test;
</code></pre>
<h1 id="二-创建表">二、创建表</h1>
<pre><code class="language-sql">CREATE TABLE mytable (
  # int 类型，不为空，自增
  id INT NOT NULL AUTO_INCREMENT,
  # int 类型，不可为空，默认值为 1，不为空
  col1 INT NOT NULL DEFAULT 1,
  # 变长字符串类型，最长为 45 个字符，可以为空
  col2 VARCHAR(45) NULL,
  # 日期类型，可为空
  col3 DATE NULL,
  # 设置主键为 id
  PRIMARY KEY (`id`));
</code></pre>
<h1 id="三-修改表">三、修改表</h1>
<p>添加列</p>
<pre><code class="language-sql">ALTER TABLE mytable
ADD col CHAR(20);
</code></pre>
<p>删除列</p>
<pre><code class="language-sql">ALTER TABLE mytable
DROP COLUMN col;
</code></pre>
<p>删除表</p>
<pre><code class="language-sql">DROP TABLE mytable;
</code></pre>
<h1 id="四-插入">四、插入</h1>
<p>普通插入</p>
<pre><code class="language-sql">INSERT INTO mytable(col1, col2)
VALUES(val1, val2);
</code></pre>
<p>插入检索出来的数据</p>
<pre><code class="language-sql">INSERT INTO mytable1(col1, col2)
SELECT col1, col2
FROM mytable2;
</code></pre>
<p>将一个表的内容插入到一个新表</p>
<pre><code class="language-sql">CREATE TABLE newtable AS
SELECT * FROM mytable;
</code></pre>
<h1 id="五-更新">五、更新</h1>
<pre><code class="language-sql">UPDATE mytable
SET col = val
WHERE id = 1;
</code></pre>
<h1 id="六-删除">六、删除</h1>
<pre><code class="language-sql">DELETE FROM mytable
WHERE id = 1;
</code></pre>
<p><strong>TRUNCATE TABLE</strong>   可以清空表，也就是删除所有行。</p>
<pre><code class="language-sql">TRUNCATE TABLE mytable;
</code></pre>
<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>
<h1 id="七-查询">七、查询</h1>
<h2 id="distinct">DISTINCT</h2>
<p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<pre><code class="language-sql">SELECT DISTINCT col1, col2
FROM mytable;
</code></pre>
<h2 id="limit">LIMIT</h2>
<p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<pre><code class="language-sql">SELECT *
FROM mytable
LIMIT 5;
</code></pre>
<pre><code class="language-sql">SELECT *
FROM mytable
LIMIT 0, 5;
</code></pre>
<p>返回第 3 ~ 5 行：</p>
<pre><code class="language-sql">SELECT *
FROM mytable
LIMIT 2, 3;
</code></pre>
<h1 id="八-排序">八、排序</h1>
<ul>
<li><strong>ASC</strong>  ：升序（默认）</li>
<li><strong>DESC</strong>  ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<pre><code class="language-sql">SELECT *
FROM mytable
ORDER BY col1 DESC, col2 ASC;
</code></pre>
<h1 id="九-过滤">九、过滤</h1>
<p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<pre><code class="language-sql">SELECT *
FROM mytable
WHERE col IS NULL;
</code></pre>
<p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt; !=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;= !&gt;</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;= !&lt;</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在两个值之间</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为 NULL 值</td>
</tr>
</tbody>
</table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong>   用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong>   操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p><strong>NOT</strong>   操作符用于否定一个条件。</p>
<h1 id="十-通配符">十、通配符</h1>
<p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li>
<p><strong>%</strong>   匹配 &gt;=0 个任意字符；</p>
</li>
<li>
<p><strong>_</strong>   匹配 ==1 个任意字符；</p>
</li>
<li>
<p><strong>[ ]</strong>   可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p>
</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<pre><code class="language-sql">SELECT *
FROM mytable
WHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本
</code></pre>
<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h1 id="十一-计算字段">十一、计算字段</h1>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用   <strong>AS</strong>   来取别名，否则输出的时候字段名为计算表达式。</p>
<pre><code class="language-sql">SELECT col1 * col2 AS alias
FROM mytable;
</code></pre>
<p><strong>CONCAT()</strong>   用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<pre><code class="language-sql">SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col
FROM mytable;
</code></pre>
<h1 id="十二-函数">十二、函数</h1>
<p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h2 id="汇总">汇总</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVG()</td>
<td style="text-align:center">返回某列的平均值</td>
</tr>
<tr>
<td style="text-align:center">COUNT()</td>
<td style="text-align:center">返回某列的行数</td>
</tr>
<tr>
<td style="text-align:center">MAX()</td>
<td style="text-align:center">返回某列的最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN()</td>
<td style="text-align:center">返回某列的最小值</td>
</tr>
<tr>
<td style="text-align:center">SUM()</td>
<td style="text-align:center">返回某列值之和</td>
</tr>
</tbody>
</table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<pre><code class="language-sql">SELECT AVG(DISTINCT col1) AS avg_col
FROM mytable;
</code></pre>
<h2 id="文本处理">文本处理</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LEFT()</td>
<td style="text-align:center">左边的字符</td>
</tr>
<tr>
<td style="text-align:center">RIGHT()</td>
<td style="text-align:center">右边的字符</td>
</tr>
<tr>
<td style="text-align:center">LOWER()</td>
<td style="text-align:center">转换为小写字符</td>
</tr>
<tr>
<td style="text-align:center">UPPER()</td>
<td style="text-align:center">转换为大写字符</td>
</tr>
<tr>
<td style="text-align:center">LTRIM()</td>
<td style="text-align:center">去除左边的空格</td>
</tr>
<tr>
<td style="text-align:center">RTRIM()</td>
<td style="text-align:center">去除右边的空格</td>
</tr>
<tr>
<td style="text-align:center">LENGTH()</td>
<td style="text-align:center">长度</td>
</tr>
<tr>
<td style="text-align:center">SOUNDEX()</td>
<td style="text-align:center">转换为语音值</td>
</tr>
</tbody>
</table>
<p>其中，  <strong>SOUNDEX()</strong>   可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre><code class="language-sql">SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre>
<h2 id="日期和时间处理">日期和时间处理</h2>
<ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函 数</th>
<th style="text-align:center">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADDDATE()</td>
<td style="text-align:center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td style="text-align:center">ADDTIME()</td>
<td style="text-align:center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td style="text-align:center">CURDATE()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CURTIME()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">DATE()</td>
<td style="text-align:center">返回日期时间的日期部分</td>
</tr>
<tr>
<td style="text-align:center">DATEDIFF()</td>
<td style="text-align:center">计算两个日期之差</td>
</tr>
<tr>
<td style="text-align:center">DATE_ADD()</td>
<td style="text-align:center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td style="text-align:center">DATE_FORMAT()</td>
<td style="text-align:center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td style="text-align:center">DAY()</td>
<td style="text-align:center">返回一个日期的天数部分</td>
</tr>
<tr>
<td style="text-align:center">DAYOFWEEK()</td>
<td style="text-align:center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td style="text-align:center">HOUR()</td>
<td style="text-align:center">返回一个时间的小时部分</td>
</tr>
<tr>
<td style="text-align:center">MINUTE()</td>
<td style="text-align:center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td style="text-align:center">MONTH()</td>
<td style="text-align:center">返回一个日期的月份部分</td>
</tr>
<tr>
<td style="text-align:center">NOW()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">SECOND()</td>
<td style="text-align:center">返回一个时间的秒部分</td>
</tr>
<tr>
<td style="text-align:center">TIME()</td>
<td style="text-align:center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td style="text-align:center">YEAR()</td>
<td style="text-align:center">返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">mysql&gt; SELECT NOW();
</code></pre>
<pre><code>2018-4-14 20:25:11
</code></pre>
<h2 id="数值处理">数值处理</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIN()</td>
<td style="text-align:center">正弦</td>
</tr>
<tr>
<td style="text-align:center">COS()</td>
<td style="text-align:center">余弦</td>
</tr>
<tr>
<td style="text-align:center">TAN()</td>
<td style="text-align:center">正切</td>
</tr>
<tr>
<td style="text-align:center">ABS()</td>
<td style="text-align:center">绝对值</td>
</tr>
<tr>
<td style="text-align:center">SQRT()</td>
<td style="text-align:center">平方根</td>
</tr>
<tr>
<td style="text-align:center">MOD()</td>
<td style="text-align:center">余数</td>
</tr>
<tr>
<td style="text-align:center">EXP()</td>
<td style="text-align:center">指数</td>
</tr>
<tr>
<td style="text-align:center">PI()</td>
<td style="text-align:center">圆周率</td>
</tr>
<tr>
<td style="text-align:center">RAND()</td>
<td style="text-align:center">随机数</td>
</tr>
</tbody>
</table>
<h1 id="十三-分组">十三、分组</h1>
<p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<pre><code class="language-sql">SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col;
</code></pre>
<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<pre><code class="language-sql">SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col
ORDER BY num;
</code></pre>
<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<pre><code class="language-sql">SELECT col, COUNT(*) AS num
FROM mytable
WHERE col &gt; 2
GROUP BY col
HAVING num &gt;= 2;
</code></pre>
<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h1 id="十四-子查询">十四、子查询</h1>
<p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<pre><code class="language-sql">SELECT *
FROM mytable1
WHERE col1 IN (SELECT col2
               FROM mytable2);
</code></pre>
<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<pre><code class="language-sql">SELECT cust_name, (SELECT COUNT(*)
                   FROM Orders
                   WHERE Orders.cust_id = Customers.cust_id)
                   AS orders_num
FROM Customers
ORDER BY cust_name;
</code></pre>
<h1 id="十五-连接">十五、连接</h1>
<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h2 id="内连接">内连接</h2>
<p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<pre><code class="language-sql">SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
</code></pre>
<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<pre><code class="language-sql">SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;
</code></pre>
<h2 id="自连接">自连接</h2>
<p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<pre><code class="language-sql">SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = &quot;Jim&quot;);
</code></pre>
<p>自连接版本</p>
<pre><code class="language-sql">SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = &quot;Jim&quot;;
</code></pre>
<h2 id="自然连接">自然连接</h2>
<p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<pre><code class="language-sql">SELECT A.value, B.value
FROM tablea AS A NATURAL JOIN tableb AS B;
</code></pre>
<h2 id="外连接">外连接</h2>
<p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<pre><code class="language-sql">SELECT Customers.cust_id, Orders.order_num
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id;
</code></pre>
<p>customers 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
</tr>
</tbody>
</table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">order_id</th>
<th style="text-align:center">cust_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">cust_id</th>
<th style="text-align:center">cust_name</th>
<th style="text-align:center">order_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">a</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">c</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">b</td>
<td style="text-align:center">Null</td>
</tr>
</tbody>
</table>
<h1 id="十六-组合查询">十六、组合查询</h1>
<p>使用   <strong>UNION</strong>   来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<pre><code class="language-sql">SELECT col
FROM mytable
WHERE col = 1
UNION
SELECT col
FROM mytable
WHERE col =2;
</code></pre>
<h1 id="十七-视图">十七、视图</h1>
<p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<pre><code class="language-sql">CREATE VIEW myview AS
SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col
FROM mytable
WHERE col5 = val;
</code></pre>
<h1 id="十八-存储过程">十八、存储过程</h1>
<p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<pre><code class="language-sql">delimiter //

create procedure myprocedure( out ret int )
    begin
        declare y int;
        select sum(col1)
        from mytable
        into y;
        select y*y into ret;
    end //

delimiter ;
</code></pre>
<pre><code class="language-sql">call myprocedure(@ret);
select @ret;
</code></pre>
<h1 id="十九-游标">十九、游标</h1>
<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<pre><code class="language-sql">delimiter //
create procedure myprocedure(out ret int)
    begin
        declare done boolean default 0;

        declare mycursor cursor for
        select col1 from mytable;
        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1
        declare continue handler for sqlstate '02000' set done = 1;

        open mycursor;

        repeat
            fetch mycursor into ret;
            select ret;
        until done end repeat;

        close mycursor;
    end //
 delimiter ;
</code></pre>
<h1 id="二十-触发器">二十、触发器</h1>
<p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<pre><code class="language-sql">CREATE TRIGGER mytrigger AFTER INSERT ON mytable
FOR EACH ROW SELECT NEW.col into @result;

SELECT @result; -- 获取结果
</code></pre>
<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h1 id="二十一-事务管理">二十一、事务管理</h1>
<p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<pre><code class="language-sql">START TRANSACTION
// ...
SAVEPOINT delete1
// ...
ROLLBACK TO delete1
// ...
COMMIT
</code></pre>
<h1 id="二十二-字符集">二十二、字符集</h1>
<p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<pre><code class="language-sql">CREATE TABLE mytable
(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )
DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;
</code></pre>
<p>可以在排序、分组时指定校对：</p>
<pre><code class="language-sql">SELECT *
FROM mytable
ORDER BY col COLLATE latin1_general_ci;
</code></pre>
<h1 id="二十三-权限管理">二十三、权限管理</h1>
<p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<pre><code class="language-sql">USE mysql;
SELECT user FROM user;
</code></pre>
<p><strong>创建账户</strong></p>
<p>新创建的账户没有任何权限。</p>
<pre><code class="language-sql">CREATE USER myuser IDENTIFIED BY 'mypassword';
</code></pre>
<p><strong>修改账户名</strong></p>
<pre><code class="language-sql">RENAME USER myuser TO newuser;
</code></pre>
<p><strong>删除账户</strong></p>
<pre><code class="language-sql">DROP USER myuser;
</code></pre>
<p><strong>查看权限</strong></p>
<pre><code class="language-sql">SHOW GRANTS FOR myuser;
</code></pre>
<p><strong>授予权限</strong></p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<pre><code class="language-sql">GRANT SELECT, INSERT ON mydatabase.* TO myuser;
</code></pre>
<p><strong>删除权限</strong></p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<pre><code class="language-sql">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;
</code></pre>
<p><strong>更改密码</strong></p>
<p>必须使用 Password() 函数进行加密。</p>
<pre><code class="language-sql">SET PASSWROD FOR myuser = Password('new_password');
</code></pre>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li>
</ul>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库系统原理]]></title>
        <id>https://thuabc.github.io/post/shu-ju-ku-xi-tong-yuan-li</id>
        <link href="https://thuabc.github.io/post/shu-ju-ku-xi-tong-yuan-li">
        </link>
        <updated>2019-12-18T15:01:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- GFM-TOC -->
<ul>
<li><a href="#%E4%B8%80%E4%BA%8B%E5%8A%A1">一、事务</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#acid">ACID</a></li>
<li><a href="#autocommit">AUTOCOMMIT</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">二、并发一致性问题</a>
<ul>
<li><a href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9">丢失修改</a></li>
<li><a href="#%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE">读脏数据</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">不可重复读</a></li>
<li><a href="#%E5%B9%BB%E5%BD%B1%E8%AF%BB">幻影读</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%B0%81%E9%94%81">三、封锁</a>
<ul>
<li><a href="#%E5%B0%81%E9%94%81%E7%B2%92%E5%BA%A6">封锁粒度</a></li>
<li><a href="#%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B">封锁类型</a></li>
<li><a href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">封锁协议</a></li>
<li><a href="#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A">MySQL 隐式与显示锁定</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">四、隔离级别</a>
<ul>
<li><a href="#%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BBread-uncommitted">未提交读（READ UNCOMMITTED）</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E8%AF%BBread-committed">提交读（READ COMMITTED）</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBrepeatable-read">可重复读（REPEATABLE READ）</a></li>
<li><a href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96serializable">可串行化（SERIALIZABLE）</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">五、多版本并发控制</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">基本思想</a></li>
<li><a href="#%E7%89%88%E6%9C%AC%E5%8F%B7">版本号</a></li>
<li><a href="#undo-%E6%97%A5%E5%BF%97">Undo 日志</a></li>
<li><a href="#readview">ReadView</a></li>
<li><a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB">快照读与当前读</a></li>
</ul>
</li>
<li><a href="#%E5%85%ADnext-key-locks">六、Next-Key Locks</a>
<ul>
<li><a href="#record-locks">Record Locks</a></li>
<li><a href="#gap-locks">Gap Locks</a></li>
<li><a href="#next-key-locks">Next-Key Locks</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA">七、关系数据库设计理论</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">函数依赖</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li>
<li><a href="#%E8%8C%83%E5%BC%8F">范式</a></li>
</ul>
</li>
<li><a href="#%E5%85%ABer-%E5%9B%BE">八、ER 图</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%81%94%E7%B3%BB">实体的三种联系</a></li>
<li><a href="#%E8%A1%A8%E7%A4%BA%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E5%85%B3%E7%B3%BB">表示出现多次的关系</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E7%9A%84%E5%A4%9A%E5%90%91%E6%80%A7">联系的多向性</a></li>
<li><a href="#%E8%A1%A8%E7%A4%BA%E5%AD%90%E7%B1%BB">表示子类</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- GFM-TOC -->
<h1 id="一-事务">一、事务</h1>
<h2 id="概念">概念</h2>
<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png"/> </div><br>
<h2 id="acid">ACID</h2>
<h3 id="1-原子性atomicity">1. 原子性（Atomicity）</h3>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性consistency">2. 一致性（Consistency）</h3>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性isolation">3. 隔离性（Isolation）</h3>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性durability">4. 持久性（Durability）</h3>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"/> </div><br>
<h2 id="autocommit">AUTOCOMMIT</h2>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h1 id="二-并发一致性问题">二、并发一致性问题</h1>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="丢失修改">丢失修改</h2>
<p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"/> </div><br>
<h2 id="读脏数据">读脏数据</h2>
<p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"/> </div><br>
<h2 id="不可重复读">不可重复读</h2>
<p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"/> </div><br>
<h2 id="幻影读">幻影读</h2>
<p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"/> </div><br>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="三-封锁">三、封锁</h1>
<h2 id="封锁粒度">封锁粒度</h2>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="封锁类型">封锁类型</h2>
<h3 id="1-读写锁">1. 读写锁</h3>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png"/> </div><br>
<h3 id="2-意向锁">2. 意向锁</h3>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png"/> </div><br>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T<sub>1</sub> 想要对数据行 R<sub>1</sub> 加 X 锁，事务 T<sub>2</sub> 想要对同一个表的数据行 R<sub>2</sub> 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h2 id="封锁协议">封锁协议</h2>
<h3 id="1-三级封锁协议">1. 三级封锁协议</h3>
<p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png"/> </div><br>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png"/> </div><br>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png"/> </div><br>
<h3 id="2-两段锁协议">2. 两段锁协议</h3>
<p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<pre><code class="language-html">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<pre><code class="language-html">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre>
<h2 id="mysql-隐式与显示锁定">MySQL 隐式与显示锁定</h2>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<pre><code class="language-sql">SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
</code></pre>
<h1 id="四-隔离级别">四、隔离级别</h1>
<h2 id="未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</h2>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="提交读read-committed">提交读（READ COMMITTED）</h2>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读repeatable-read">可重复读（REPEATABLE READ）</h2>
<p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<h2 id="可串行化serializable">可串行化（SERIALIZABLE）</h2>
<p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<hr>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png"/> </div><br>
<h1 id="五-多版本并发控制">五、多版本并发控制</h1>
<p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="基本思想">基本思想</h2>
<p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h2 id="版本号">版本号</h2>
<ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h2 id="undo-日志">Undo 日志</h2>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<pre><code class="language-sql">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);
UPDATE t SET x=&quot;b&quot; WHERE id=1;
UPDATE t SET x=&quot;c&quot; WHERE id=1;
</code></pre>
<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID  写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h2 id="readview">ReadView</h2>
<p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/> </div><br>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>
<p>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</p>
</li>
<li>
<p>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</p>
</li>
<li>
<p>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：</p>
<ul>
<li>提交读：如果 TRX_ID  在 TRX_IDs  列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR  找到下一个快照，再进行上面的判断。</p>
<h2 id="快照读与当前读">快照读与当前读</h2>
<h3 id="1-快照读">1. 快照读</h3>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<pre><code class="language-sql">SELECT * FROM table ...;
</code></pre>
<h3 id="2-当前读">2. 当前读</h3>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<pre><code class="language-sql">INSERT;
UPDATE;
DELETE;
</code></pre>
<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<pre><code class="language-sql">SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
</code></pre>
<h1 id="六-next-key-locks">六、Next-Key Locks</h1>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h2 id="record-locks">Record Locks</h2>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="gap-locks">Gap Locks</h2>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<pre><code class="language-sql">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
</code></pre>
<h2 id="next-key-locks">Next-Key Locks</h2>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<pre><code class="language-sql">(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
</code></pre>
<h1 id="七-关系数据库设计理论">七、关系数据库设计理论</h1>
<h2 id="函数依赖">函数依赖</h2>
<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A'，使得 A'-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常">异常</h2>
<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式">范式</h2>
<p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h3 id="1-第一范式-1nf">1. 第一范式 (1NF)</h3>
<p>属性不可分。</p>
<h3 id="2-第二范式-2nf">2. 第二范式 (2NF)</h3>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size=4>  <strong>分解前</strong>  </font><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size=4>  <strong>分解后</strong>  </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h3 id="3-第三范式-3nf">3. 第三范式 (3NF)</h3>
<p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h1 id="八-er-图">八、ER 图</h1>
<p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h2 id="实体的三种联系">实体的三种联系</h2>
<p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" width="380px"/> </div><br>
<h2 id="表示出现多次的关系">表示出现多次的关系</h2>
<p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" width="250px"/> </div><br>
<h2 id="联系的多向性">联系的多向性</h2>
<p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" width="350px"/> </div><br>
<h2 id="表示子类">表示子类</h2>
<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" width="450px"/> </div><br>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>
<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[遍历二叉树]]></title>
        <id>https://thuabc.github.io/post/er-cha-shu-bian-li</id>
        <link href="https://thuabc.github.io/post/er-cha-shu-bian-li">
        </link>
        <updated>2019-12-18T14:43:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1-二叉树的中序遍历">1、二叉树的中序遍历</h2>
<p>递归解法</p>
<pre><code class="language-java"> //递归解法
class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        helper(root, res);
        return res;
    }
    public void helper(TreeNode root, List&lt;Integer&gt; res){
        if(root!=null){
            if(root.left!=null){
                helper(root.left, res);
            }
            res.add(root.val);
            if(root.right!=null){
                helper(root.right, res);
            }
        }
    }  
}
</code></pre>
<p>非递归解法</p>
<h2 id="2-二叉树的前序遍历">2、二叉树的前序遍历</h2>
<p>递归解法</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if(root==null){
            return res;
        }
        helper(root, res);
        return res;
    }
    public void helper(TreeNode root, List&lt;Integer&gt; res){
        res.add(root.val);
        if(root.left!=null){
            helper(root.left, res);
        }
        if(root.right!=null){
            helper(root.right, res);
        }
    }
}
</code></pre>
<p>非递归解法</p>
<h2 id="3-二叉树的后序遍历">3、二叉树的后序遍历</h2>
<p>递归解法</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        helper(root, res);
        return res;
    }
    public void helper(TreeNode root, List&lt;Integer&gt; res){
        if(root==null){
            return;
        }
        if(root.left!=null){
            helper(root.left, res);
        }
        if(root.right!=null){
            helper(root.right, res);
        }
        res.add(root.val);
    }
}
</code></pre>
<p>非递归解法</p>
<h2 id="4-二叉树的层次遍历">4、二叉树的层次遍历</h2>
<p>递归解法<br>
非递归解法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA集合]]></title>
        <id>https://thuabc.github.io/post/java-ji-he</id>
        <link href="https://thuabc.github.io/post/java-ji-he">
        </link>
        <updated>2019-12-17T12:41:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://thuabc.github.io/post-images/1576678939495.png" alt=""></figure>
<h3 id="1hashmap-和-hashtable-有什么区别">1.HashMap 和 Hashtable 有什么区别？</h3>
<ul>
<li>HashMap是非线程安全的，HashTable是线程安全的。</li>
<li>HashMap的键和值都允许有null值存在，而HashTable则不行。 因为线程安全的问题，HashMap效率比HashTable的要高。</li>
<li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>
一般现在不建议用HashTable,<br>
①是HashTable是遗留类，内部实现很多没优化和冗余。<br>
②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li>
</ul>
<h3 id="2arraylist-和-vector-的区别是什么">2.ArrayList 和 Vector 的区别是什么？</h3>
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h3 id="3arraylist-和-linkedlist-的区别是什么">3.ArrayList 和 LinkedList 的区别是什么？</h3>
<ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>
综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
</ul>
<h3 id="4哪些集合类是线程安全的">4.哪些集合类是线程安全的？</h3>
<p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h3 id="5如何实现数组和-list-之间的转换">5.如何实现数组和 List 之间的转换</h3>
<ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。<br>
代码示例：</li>
</ul>
<pre><code class="language-java">  // list to array
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list. add(&quot;诗情&quot;);
list. add(&quot;画意&quot;);
list. toArray();
// array to list
String[] array = new String[]{&quot;诗情&quot;,&quot;画意&quot;};
Arrays. asList(array);
</code></pre>
<h3 id="6hashmap-的实现原理">6.HashMap 的实现原理？</h3>
<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表，否则使用红黑树。</p>
<h3 id="7collection-和-collections-有什么区别">7.Collection 和 Collections 有什么区别？</h3>
<ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。</li>
</ul>
<h3 id="8在-queue-中-poll和-remove有什么区别">8.在 Queue 中 poll()和 remove()有什么区别？</h3>
<ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出NoSuchElementException 异常。</li>
</ul>
<h3 id="9迭代器-iterator-是什么怎么使用有什么特点">9.迭代器 Iterator 是什么？怎么使用？有什么特点？</h3>
<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。<br>
Iterator 使用代码如下：</p>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
Iterator&lt;String&gt; it = list. iterator();
while(it. hasNext()){
  String obj = it. next();
  System. out. println(obj);
}
</code></pre>
<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h3 id="10-iterator-和-listiterator-有什么区别">10. Iterator 和 ListIterator 有什么区别？</h3>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
<h3 id="11怎么确保一个集合不能被修改">11.怎么确保一个集合不能被修改？</h3>
可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list. add(&quot;x&quot;);
Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);
clist. add(&quot;y&quot;); // 运行时此行报错
System. out. println(list. size());
</code></pre>
<h3 id="12数组array与arraylist-有何区别">12.数组Array与ArrayList 有何区别？</h3>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h3 id="13如何决定使用-hashmap-还是-treemap">13.如何决定使用 HashMap 还是 TreeMap？</h3>
<p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h3 id="14list-set-map-之间的区别是什么">14.List、Set、Map 之间的区别是什么？</h3>
<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。<br>
三者之间的区别，如下表：<br>
<img src="https://thuabc.github.io/post-images/1576679140466.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://thuabc.github.io/post/er-fen-cha-zhao</id>
        <link href="https://thuabc.github.io/post/er-fen-cha-zhao">
        </link>
        <updated>2019-12-16T15:56:57.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先排好序，可以在数据规模的对数时间复杂度内完成查找。但是，二分查找要求线性表具有有随机访问的特点（例如数组），也要求线性表能够根据中间元素的特点推测它两侧元素的性质，以达到缩减问题规模的效果。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</p>
<pre><code class="language-java">//不使用递归实现（while循环）
/**
 * 二分查找，找到该值在数组中的下标，否则返回-1
 */
static int binarySerach(int[] array, int key) {
    int left = 0;
    int right = array.length - 1;
    
    if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high){
			return -1;				
		}
    
    // 这里必须是 &lt;=
    while (left &lt;= right) {
        int mid = (left + right) / 2;
        if (array[mid] == key) {
            return mid;
        }
        else if (array[mid] &lt; key) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }

    return -1;
}
</code></pre>
<pre><code class="language-java">//递归实现
public static int recursionBinarySearch(int[] arr,int key,int low,int high){
		
		if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high){
			return -1;				
		}
		
		int middle = (low + high) / 2;			//初始中间位置
		if(arr[middle] &gt; key){
			//比关键字大则关键字在左区域
			return recursionBinarySearch(arr, key, low, middle - 1);
		}else if(arr[middle] &lt; key){
			//比关键字小则关键字在右区域
			return recursionBinarySearch(arr, key, middle + 1, high);
		}else {
			return middle;
		}	
		
	}
</code></pre>
<h3 id="二分查找总结">二分查找总结</h3>
<pre><code class="language-java">// 这里必须是 &lt;=
while (left &lt;= right) {
    int mid = (left + right) / 2;
    if (array[mid] ? key) {//2.判断出比较符号
        //... right = mid - 1;
    }
    else {
        // ... left = mid + 1;
    }
}
return xxx;//1.首先判断返回left，还是right
</code></pre>
<h3 id="时间复杂度">时间复杂度</h3>
<p>采用的是分治策略</p>
<p>最坏的情况下两种方式时间复杂度一样：O(log2N)</p>
<p>最好情况下为：O(1)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数</p>
<p>非递归方式：<br>
由于辅助空间是常数级别的，所以：<br>
空间复杂度是O(1);</p>
<p>递归方式：</p>
<p>递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的，所以：<br>
空间复杂度：O(log2N )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表-Leetcode]]></title>
        <id>https://thuabc.github.io/post/listnode-leetcode-java</id>
        <link href="https://thuabc.github.io/post/listnode-leetcode-java">
        </link>
        <updated>2019-12-16T12:39:26.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="leetcode-19-删除链表的倒数第n个节点">😃LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a></h3>
<pre><code class="language-java">//两次遍历法
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        int length  = 0;
        ListNode first = head;
        while (first != null) {
            length++;
            first = first.next;
        }
        length -= n;
        first = dummy;
        while (length &gt; 0) {
            length--;
            first = first.next;
        }
        first.next = first.next.next;
        return dummy.next;
    }
}
</code></pre>
<h3 id="leetcode-24-两两交换链表中的节点">😁LeetCode <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3>
<pre><code class="language-java">class Solution {
    public ListNode swapPairs(ListNode head) {
        //头插法
        ListNode dumb = new ListNode(0);
        dumb.next = head;
        ListNode temp = dumb;
        while(temp.next!=null&amp;&amp;temp.next.next!=null){
            ListNode start = temp.next;
            ListNode end = temp.next.next;
            temp.next = end;
            start.next = end.next;
            end.next = start;
            temp = start;
        }
        return dumb.next;   
    }
}
</code></pre>
<h3 id="leecode-83-删除排序链表中的重复元素">LeeCode <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3>
<pre><code class="language-java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        //这里不用哑结点
        ListNode cur = head;
        while(cur != null &amp;&amp; cur.next != null){
            if(cur.next.val == cur.val){
                cur.next = cur.next.next;
            }else{
                cur = cur.next;
            }
        }
        return head;   
    }
}
</code></pre>
<h3 id="leetcode-141-环形链表">LeetCode <a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h3>
<pre><code class="language-java"> //HashSet解法：add, remove,isEmpty,contains,clear,size
 /**
public class Solution {
    public boolean hasCycle(ListNode head) {
       HashSet&lt;ListNode&gt; hasExist = new HashSet&lt;&gt;();
       while(head != null){
           if(hasExist.contains(head)){
               return true;
           }else{
               hasExist.add(head);
               head = head.next;
           }
       }
        return false;
    }
}
 */
//双指针解法
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null||head.next==null){
            return false;
        }
        //快慢指针
        ListNode slow = head;
        ListNode fast = head.next;
        //循环终止条件：slow==fast
        while(slow!=fast){
            if(fast==null||fast.next==null){
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
</code></pre>
<h3 id="leetcode-203-移除链表元素">LeetCode <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3>
<pre><code class="language-java">//头插法
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //因为head.val可能等于val,所以需要new一个哑结点，并且指向头结点
        ListNode dumb = new ListNode(0);
        dumb.next = head;
        //用于遍历链表的指针
        ListNode cur = dumb;
        //循环条件cur.next!=null
        while(cur.next!=null){
            if(cur.next.val==val){
                cur.next = cur.next.next;   
            }else{//这里要用else,因为存在连续等于val的结点
                cur = cur.next;
            }
        }
        return dumb.next;     
    }
}
</code></pre>
<h3 id="leetcode-206-反转链表">LeetCode <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3>
<pre><code class="language-java">//迭代法
class Solution {
    public ListNode reverseList(ListNode head) {
        //头结点指向null
        ListNode prev = null;
        ListNode temp = head;
        while(temp!=null){
			ListNode nextTemp = temp.next;
            temp.next = prev;
            prev = temp;
            temp = nextTemp;
        }
        return prev;
    }
}
</code></pre>
<h3 id="leetcode-876-链表的中间结点">LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h3>
<pre><code class="language-java">class Solution {
    public ListNode middleNode(ListNode head) {
        //快慢指针
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null&amp;&amp;fast.next!=null){
            //慢指针走一步快指针走两步
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;  
    }
}
</code></pre>
<p>头插法，哑巴结点（dumb，dumb.next=head)，遍历指针（temp=head，或temp=dumb）(temp=temp.next），循环条件(temp!=null，temp.next!=null），快慢指针，删除结点（temp.next=temp.next.next）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://thuabc.github.io/post/hello-gridea</id>
        <link href="https://thuabc.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://thuabc.github.io/post-images/1576513014433.png" alt=""></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://thuabc.github.io/post-images/1576513014433.png" alt=""></figure>
<!-- more -->
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>